{"version":3,"file":"namespaced-event-delegation.modern.js","sources":["../src/event-manager.ts","../src/namespaced-event-delegation.ts"],"sourcesContent":["interface EventsItem {\n  element;\n  eventName: string;\n  handler;\n}\n\ninterface EventsItems extends Array<EventsItem> {}\n\nexport default class EventManagerSingleton {\n  private eventsMap: EventsItems = [];\n\n  static instance: EventManagerSingleton;\n\n  constructor() {\n    if (EventManagerSingleton.instance) {\n      return EventManagerSingleton.instance;\n    }\n\n    EventManagerSingleton.instance = this;\n    return this;\n  }\n\n  addEvent = (element, eventName, handler) => {\n    this.eventsMap.push({ element, eventName, handler });\n    return handler;\n  };\n\n  removeEvents = (element, eventName): boolean => {\n    const eventsRemoved = 0;\n    this.eventsMap = this.eventsMap.filter(\n      (event, index) =>\n        event.element === element && event.eventName === eventName && delete this.eventsMap[index] && eventsRemoved + 1\n    );\n    return !!eventsRemoved;\n  };\n\n  getEvents = (eventName = undefined): EventsItems =>\n    eventName ? this.eventsMap.filter((event) => event.eventName === eventName) : this.eventsMap;\n\n  clearEvents = () => {\n    this.eventsMap = [];\n  };\n}\n","interface EventLabels {\n  events: string;\n  elements: string | HTMLElement;\n}\n\ninterface DelegatedEvent extends EventLabels {\n  handler: Function;\n  targets?: string;\n  once?: boolean;\n}\nimport EventManager from './event-manager';\n\nexport default class NamespacedEventDelegation extends EventManager {\n  public on = ({ events, elements, targets, handler, once = false }: DelegatedEvent) => {\n    this.candidates(elements, events, (element, eventNamespace) => {\n      element.addEventListener(\n        this.extractEventName(eventNamespace),\n        this.addEvent(element, eventNamespace, (originalEvent) => {\n          let handlerParams = {\n            event: eventNamespace,\n            delegatedTarget: element,\n            currentTarget: element,\n            originalEvent\n          };\n\n          if (targets) {\n            const target = originalEvent.target.closest(targets);\n            if (!target) {\n              return false;\n            }\n\n            handlerParams = {\n              ...handlerParams,\n              currentTarget: target || handlerParams.delegatedTarget\n            };\n          }\n          return handler(handlerParams);\n        }),\n        { once }\n      );\n    });\n  };\n\n  public once = ({ events, elements, targets, handler }: DelegatedEvent) =>\n    this.on({ events, elements, targets, handler, once: true });\n\n  public off = ({ elements, events }: EventLabels): boolean[] => {\n    const removed = [];\n    this.getEvents().forEach((storedEvent) => {\n      this.candidates(elements, events, (element, event) => {\n        element.removeEventListener(this.extractEventName(event), storedEvent.handler);\n        removed.push(this.removeEvents(element, event));\n      });\n    });\n\n    return removed;\n  };\n\n  public fire = ({ elements, events }: EventLabels): boolean[] => {\n    const fired = [];\n    const evt = document.createEvent('Event');\n\n    this.candidates(elements, events, (element, event) => {\n      evt.initEvent(this.extractEventName(event), true, true);\n      fired.push(element.dispatchEvent(evt));\n    });\n\n    return fired;\n  };\n\n  private candidates = (elements, events, fn) => {\n    const elementsArr = typeof elements === 'string' ? document.querySelectorAll(elements) : [elements];\n    const eventsArr = events.split(' ');\n    elementsArr.forEach((element) => eventsArr.forEach((event) => fn(element, event)));\n  };\n\n  private extractEventName = (eventName) => eventName.split('.')[0];\n}\n"],"names":["EventManagerSingleton","constructor","this","element","eventName","handler","eventsMap","push","filter","event","index","eventsRemoved","instance","EventManager","events","elements","targets","once","candidates","eventNamespace","addEventListener","extractEventName","addEvent","originalEvent","handlerParams","delegatedTarget","currentTarget","target","closest","on","removed","getEvents","forEach","storedEvent","removeEventListener","removeEvents","fired","evt","document","createEvent","initEvent","dispatchEvent","fn","elementsArr","querySelectorAll","eventsArr","split"],"mappings":"qNAQqBA,EAKnBC,cACE,OALMC,eAAyB,GAajCA,cAAW,CAACC,EAASC,EAAWC,KAC9BH,KAAKI,UAAUC,KAAK,CAAEJ,QAAAA,EAASC,UAAAA,EAAWC,QAAAA,IACnCA,GAGTH,kBAAe,CAACC,EAASC,KAEvBF,KAAKI,UAAYJ,KAAKI,UAAUE,OAC9B,CAACC,EAAOC,IACND,EAAMN,UAAYA,GAAWM,EAAML,YAAcA,eAAyBE,UAAUI,IAAUC,IAE3F,GAGTT,eAAaE,GACXA,EAAYF,KAAKI,UAAUE,OAAQC,GAAUA,EAAML,YAAcA,GAAaF,KAAKI,UAErFJ,iBAAc,KACZA,KAAKI,UAAY,IA1BbN,EAAsBY,SACjBZ,EAAsBY,UAG/BZ,EAAsBY,SAAWV,yCCNkBW,EAAvDZ,kCACSC,QAAK,EAAGY,OAAAA,EAAQC,SAAAA,EAAUC,QAAAA,EAASX,QAAAA,EAASY,KAAAA,GAAO,MACxDf,KAAKgB,WAAWH,EAAUD,EAAQ,CAACX,EAASgB,KAC1ChB,EAAQiB,iBACNlB,KAAKmB,iBAAiBF,GACtBjB,KAAKoB,SAASnB,EAASgB,EAAiBI,IACtC,IAAIC,EAAgB,CAClBf,MAAOU,EACPM,gBAAiBtB,EACjBuB,cAAevB,EACfoB,cAAAA,GAGF,GAAIP,EAAS,CACX,MAAMW,EAASJ,EAAcI,OAAOC,QAAQZ,GAC5C,IAAKW,EACH,SAGFH,OACKA,GACHE,cAAeC,GAAUH,EAAcC,kBAG3C,OAAOpB,EAAQmB,KAEjB,CAAEP,KAAAA,OAKDf,UAAO,EAAGY,OAAAA,EAAQC,SAAAA,EAAUC,QAAAA,EAASX,QAAAA,KAC1CH,KAAK2B,GAAG,CAAEf,OAAAA,EAAQC,SAAAA,EAAUC,QAAAA,EAASX,QAAAA,EAASY,MAAM,IAE/Cf,SAAM,EAAGa,SAAAA,EAAUD,OAAAA,MACxB,MAAMgB,EAAU,GAQhB,OAPA5B,KAAK6B,YAAYC,QAASC,IACxB/B,KAAKgB,WAAWH,EAAUD,EAAQ,CAACX,EAASM,KAC1CN,EAAQ+B,oBAAoBhC,KAAKmB,iBAAiBZ,GAAQwB,EAAY5B,SACtEyB,EAAQvB,KAAKL,KAAKiC,aAAahC,EAASM,QAIrCqB,GAGF5B,UAAO,EAAGa,SAAAA,EAAUD,OAAAA,MACzB,MAAMsB,EAAQ,GACRC,EAAMC,SAASC,YAAY,SAOjC,OALArC,KAAKgB,WAAWH,EAAUD,EAAQ,CAACX,EAASM,KAC1C4B,EAAIG,UAAUtC,KAAKmB,iBAAiBZ,IAAQ,GAAM,GAClD2B,EAAM7B,KAAKJ,EAAQsC,cAAcJ,MAG5BD,GAGDlC,gBAAa,CAACa,EAAUD,EAAQ4B,KACtC,MAAMC,EAAkC,iBAAb5B,EAAwBuB,SAASM,iBAAiB7B,GAAY,CAACA,GACpF8B,EAAY/B,EAAOgC,MAAM,KAC/BH,EAAYX,QAAS7B,GAAY0C,EAAUb,QAASvB,GAAUiC,EAAGvC,EAASM,MAGpEP,sBAAoBE,GAAcA,EAAU0C,MAAM,KAAK"}